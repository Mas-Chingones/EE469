// Module Dependencies:
//`include "sram.v"

/*
Author: Ian Gilman
Title: SRAM Test on De1-soc
Summary: Test SRAM operation using De1-soc dev board.
*/

module sram_test_de1soc(CLOCK_50, SW, KEY, LEDR);
	input wire CLOCK_50;  // 50 MHz clock
	input wire [1:0] KEY;  // keypad 
	input wire [9:0] SW;  // switches
	output wire [9:0] LEDR;  // LED's
	wire sys_clk, cs, oe, rw;  // system clock, !chip select, sram !out enable, read/!write 
	wire [7:0] sw_data;  // data from switches
	wire [31:0] clocks, data_bus, read_data, address;  // divide clocks, data bus, data read from bus, address
	reg [7:0] led_data;  // data to leds
	
	
	reg [6:0] write_data;  // data written to bus
	
	// Interface signal assignment
	assign LEDR[6:0] = led_data;
	assign LEDR[9:7] = 3'b0;
	assign sw_data = SW[6:0];
	//assign address = {30'b0, {SW[9:8]}};
	assign cs = KEY[0];
	assign oe = !KEY[1];
	assign rw = KEY[1];
	
	// divide 50 MHz clock to get sys clock
	assign sys_clk = clocks[0];
	div_clock clock_divider(.orig_clk(CLOCK_50), .div_clks(clocks));
	
	// write to bus
	assign data_bus = (oe && !rw) ? write_data : 7'b0;
	// read bus
	assign read_data = (!oe && rw) ? data_bus : 7'b0;
	
	
	always @(*) begin
		LEDR[6:0] = value;
		SW[6:0] = address;
		
	end
	
	
	// SRAM
	sram memory(
			.clk(sys_clk),
			.cs(cs),
			.oe(oe),
			.rw(rw),
			//.addr_bus(address),
			.addr_bus({25'b0, address}),
			.data_bus({25'b0, value})
    	  );
 	
	reg [6:0] address;
	reg [6:0] value;
	reg [1:0] state;
	
	always @(posedge sys_clk or negedge reset) begin
		case (state)
		
			2'b00: begin
				if(!reset)
					value <= 7'b1;
					address <= 7'b0;
				else if (counter != 7'b0 && address != 7'b1) begin
					value <= value - 1;
					address <= address + 1;
				end
				state = 1'b1;
			end
			
			2'b01: begin
				cs =0;
				rw = 0;
				oe = 1;
				state = 2'b10;
			end
			
			2'b10: begin
				state = 2'b00;
			end
			
			default state = 2'b00;
		
		endcase
	end

	
	
/*
Author: Ian Gilman
Title: clock divider
Summary: create vector of divided clocks based on original clock
*/

module div_clock(orig_clk, div_clks);
	input wire orig_clk;
	output reg [31:0] div_clks;

	// increment vector of clocks for every orig_clk pulse
	always @(posedge orig_clk) begin
		div_clks = div_clks + 32'b1;
	end	
endmodule