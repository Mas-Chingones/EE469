$date
	Fri Jun 03 15:58:27 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module buffer_testbench $end
$scope module if_id_dut $end
$var wire 1 ! stall $end
$var wire 1 " rst $end
$var wire 32 # instruction_out [31:0] $end
$var wire 32 $ instruction [31:0] $end
$var wire 1 % clk $end
$var reg 32 & instruction_saved [31:0] $end
$upscope $end
$upscope $end
$scope module buffer_testbench $end
$scope module id_ex_dut $end
$var wire 3 ' wb_ctrl_out [2:0] $end
$var wire 3 ( wb_ctrl [2:0] $end
$var wire 1 ) stall $end
$var wire 1 " rst $end
$var wire 32 * r_data_1 [31:0] $end
$var wire 32 + r_data_0 [31:0] $end
$var wire 3 , mem_ctrl_out [2:0] $end
$var wire 3 - mem_ctrl [2:0] $end
$var wire 32 . instruction_out [31:0] $end
$var wire 32 / instruction [31:0] $end
$var wire 7 0 ex_ctrl_out [6:0] $end
$var wire 7 1 ex_ctrl [6:0] $end
$var wire 1 % clk $end
$var reg 7 2 ex_ctrl_saved [6:0] $end
$var reg 32 3 instruction_saved [31:0] $end
$var reg 3 4 mem_ctrl_saved [2:0] $end
$var reg 32 5 r_data_0_out [31:0] $end
$var reg 32 6 r_data_1_out [31:0] $end
$var reg 3 7 wb_ctrl_saved [2:0] $end
$upscope $end
$upscope $end
$scope module buffer_testbench $end
$scope module ex_mem_dut $end
$var wire 3 8 wb_ctrl [2:0] $end
$var wire 1 " rst $end
$var wire 1 9 mem_fwd $end
$var wire 32 : mem_data_forward [31:0] $end
$var wire 3 ; mem_ctrl [2:0] $end
$var wire 32 < instruction [31:0] $end
$var wire 32 = data_to_mem_saved [31:0] $end
$var wire 32 > data_to_mem [31:0] $end
$var wire 1 % clk $end
$var wire 32 ? alu_data [31:0] $end
$var reg 32 @ alu_data_out [31:0] $end
$var reg 32 A data_to_mem_out [31:0] $end
$var reg 32 B instruction_out [31:0] $end
$var reg 3 C mem_ctrl_out [2:0] $end
$var reg 3 D wb_ctrl_out [2:0] $end
$upscope $end
$upscope $end
$scope module buffer_testbench $end
$scope module mem_wb_dut $end
$var wire 32 E alu_data [31:0] $end
$var wire 32 F instruction [31:0] $end
$var wire 3 G wb_ctrl [2:0] $end
$var wire 1 " rst $end
$var wire 32 H mem_data [31:0] $end
$var wire 1 % clk $end
$var reg 32 I alu_data_out [31:0] $end
$var reg 32 J instruction_out [31:0] $end
$var reg 32 K mem_data_out [31:0] $end
$var reg 3 L wb_ctrl_out [2:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 L
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
b100 C
b0 B
b0 A
b0 @
b0 ?
b0 >
b0 =
b0 <
b100 ;
b0 :
09
b0 8
b0 7
b0 6
b0 5
b100 4
b0 3
b0 2
b1 1
b0 0
b0 /
b0 .
b100 -
b100 ,
bx +
bx *
0)
b0 (
b0 '
b0 &
1%
b0 $
b0 #
0"
0!
$end
#10
0%
#20
b1 0
bx 6
bx 5
b1 2
1"
1%
#30
0%
#40
b1110000000000000000000000000000 $
1%
#50
0%
#60
b1110000000000000000000000000000 #
b1110000000000000000000000000000 /
b1110000000000000000000000000000 &
b110000001100000011000000110 *
b110000001100000011000000110000 +
b10 -
b100 (
b1100000000000000000000000000000 $
1%
#70
0%
#80
b1100000000000000000000000000000 #
b1100000000000000000000000000000 /
b1110000000000000000000000000000 .
b1110000000000000000000000000000 <
b10 ,
b10 ;
b100 '
b100 8
b1 =
b1100000000000000000000000000000 &
b1110000000000000000000000000000 3
b110000001100000011000000110 6
b110000001100000011000000110000 5
b10 4
b100 7
b10 :
b1 >
b110110001101100011011000110110 ?
b1100010 *
b100011 +
b1 -
b10 1
b101 (
b10000000000000000000000000000000 $
1%
#90
0%
#100
b1100000000000000000000000000000 .
b1100000000000000000000000000000 <
b10 0
b1 ,
b1 ;
b101 '
b101 8
b10000000000000000000000000000000 #
b10000000000000000000000000000000 /
b101 =
b1110000000000000000000000000000 B
b1110000000000000000000000000000 F
b1 A
b110110001101100011011000110110 @
b110110001101100011011000110110 E
b10 C
b100 D
b100 G
b1100000000000000000000000000000 3
b1100010 6
b100011 5
b10 2
b1 4
b101 7
b10000000000000000000000000000000 &
b11 H
b110 :
b101 >
b0 ?
b10 *
b1010 +
b0 -
b0 1
b100 (
b10010 $
1%
#110
0%
#120
b10000000000000000000000000000000 .
b10000000000000000000000000000000 <
b0 0
b0 ,
b0 ;
b100 '
b100 8
b10 =
b0 #
b0 /
b10010 &
b10000000000000000000000000000000 3
b10 6
b1010 5
b0 2
b0 4
b100 7
b1100000000000000000000000000000 B
b1100000000000000000000000000000 F
b101 A
b0 @
b0 E
b1 C
b101 D
b101 G
b1110000000000000000000000000000 J
b11 K
b110110001101100011011000110110 I
b100 L
b100 H
b1000101 :
b10 >
b101000 ?
b11 *
b10011 +
b111 -
b11 1
b101 (
b100000000000000000000000000000 $
1!
1%
#130
0%
#140
b0 .
b0 <
b11 0
b111 ,
b111 ;
b101 '
b101 8
b10100 =
b10010 #
b10010 /
b1100000000000000000000000000000 J
b100 K
b0 I
b101 L
b10000000000000000000000000000000 B
b10000000000000000000000000000000 F
b10 A
b101000 @
b101000 E
b0 C
b100 D
b100 G
b0 3
b11 6
b10011 5
b11 2
b111 4
b101 7
b11 H
b10100 :
b0 >
b10000 ?
b0 *
b1110001 +
b100 -
b100 1
b111 (
b11001000000000000000000000000 $
19
0!
1%
#150
0%
#160
b11001000000000000000000000000 #
b11001000000000000000000000000 /
b0 0
b100 ,
b100 ;
b11 '
b11 8
b1 =
b11001000000000000000000000000 &
b10010 3
b0 6
b1110001 5
b100 2
b100 4
b111 7
b0 B
b0 F
b10100 A
b10000 @
b10000 E
b111 C
b101 D
b101 G
b10000000000000000000000000000000 J
b11 K
b101000 I
b100 L
b111 H
b1000 :
b1 >
b1110001 ?
b1101111000 *
b100010 +
b1 -
b10 1
b10 (
b1000000000000000000000000000000 $
1)
09
1%
#170
0%
#180
b101 =
b0 #
b0 /
b0 J
b111 K
b10000 I
b101 L
b1 A
b1110001 @
b1110001 E
b100 C
b11 D
b11 G
b1000000000000000000000000000000 &
b11 H
b110 :
b101 >
b0 ?
b10 *
b1010 +
b0 -
b0 1
b100 (
b10011000000000000000000000000 $
1!
1%
#190
0%
#200
b101 A
b0 @
b0 E
b11 K
b1110001 I
b11 L
1%
